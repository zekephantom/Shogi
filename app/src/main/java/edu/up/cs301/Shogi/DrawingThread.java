package edu.up.cs301.Shogi;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.view.SurfaceHolder;

import java.util.ArrayList;
import java.util.List;

/**
 * External Citation
 *   Date: 16 September 2024
 *   Problem: Needed a way to draw a 9x9 grid inside the Surface View feature, so I asked AI for help on how to implement the grid;
 *           Recommended to use the Thread class and synchronized() block for future developments
 *   Resource: ChatGPT
 *   Solution: AI suggested to create a DrawingThread class that extends Thread. I used the code generated by AI.
 * */
public class DrawingThread extends Thread {
    private SurfaceHolder surfaceHolder;
    private boolean running = false;
    private boolean needsRedraw = false;
    private final Object lock = new Object();

    private List<ShogiPiece> shogiPieces;
    private List<ShogiPiece> capturedPieces;
    private List<Bitmap> scaledBitmaps;
    private float cellWidth;
    private float cellHeight;
    private float cellDimensions;
    private float fieldDimensions;
    private float capturedFieldRadius;

    public DrawingThread(SurfaceHolder holder, List<ShogiPiece> shogiPieces, List<ShogiPiece> capturedPieces) {
        this.surfaceHolder = holder;
        this.shogiPieces = shogiPieces;
        this.capturedPieces = capturedPieces;
        this.scaledBitmaps = new ArrayList<>();
    }

    public void setRunning(boolean isRunning) {
        synchronized (lock) {
            this.running = isRunning;
            if (running) {
                lock.notify(); // Wake up the thread if it's waiting
            }
        }
    }

    public void requestRedraw() {
        synchronized (lock) {
            needsRedraw = true;
            lock.notify(); // Notify the thread to redraw
        }
    }

    public float getCellWidth() {
        return cellWidth;
    }

    public float getCellHeight() {
        return cellHeight;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (lock) {
                if (!running) {
                    break; // Exit the loop if not running
                }
                if (!needsRedraw) {
                    try {
                        lock.wait(); // Wait until notified
                    } catch (InterruptedException e) {
                        // Handle interruption
                    }
                    continue;
                }
                needsRedraw = false;
            }

            Canvas canvas = surfaceHolder.lockCanvas();
            if (canvas != null) {
                synchronized (surfaceHolder) {
                    drawGrid(canvas);
                }
                surfaceHolder.unlockCanvasAndPost(canvas);
            }
        }
    }

    private void drawGrid(Canvas canvas) {
        // Clear the canvas
        canvas.drawColor(Color.WHITE);

        int width = canvas.getWidth();
        int height = canvas.getHeight();



        // Calculate cell size

        cellWidth = width / 11f;
        cellHeight = height / 9f;


        // uses the value that will make the chess board fit proper while still being squared
        cellDimensions = Math.min(cellWidth, cellHeight);

        capturedFieldRadius = (float) (0.4*cellDimensions);

        fieldDimensions = cellDimensions*9;

        // debugging
        /*
        Log.i("cellSize", "Cellwidth: "+cellWidth);
        Log.i("cellSize", "Cellheight: "+cellHeight);
        Log.i("cellSize", "Celldim: "+cellDimensions);
        */

        // Initializing colors used
        Paint paintBlack = new Paint();
        Paint paintBackground = new Paint();
        Paint paintCapturedField = new Paint();
        paintBlack.setColor(Color.BLACK);
        paintBlack.setStrokeWidth(4);
        paintBackground.setColor(0xFF926211);
        paintCapturedField.setColor(0xa3d3d3d3);

        // add background
        canvas.drawRect(0,0,width,height, paintBlack);
        // add background color for board
        canvas.drawRect(cellDimensions,0, cellDimensions+fieldDimensions, fieldDimensions, paintBackground);

        // Draw vertical lines
        for (int i = 1; i <= 10; i++) { // start at 1-10 when adding captured pieces
            float x = i * cellDimensions;
            canvas.drawLine(x, 0, x, fieldDimensions, paintBlack);
        }

        // Draw horizontal lines
        for (int i = 0; i <= 9; i++) {
            float y = i * cellDimensions;
            canvas.drawLine(cellDimensions, y, cellDimensions+fieldDimensions, y, paintBlack);
        }

        // Draw 4 circles to indicate promotion zones
            canvas.drawCircle(cellDimensions*4, cellDimensions*3,cellDimensions/13, paintBlack);
            canvas.drawCircle(cellDimensions*7, cellDimensions*3,cellDimensions/13, paintBlack);
            canvas.drawCircle(cellDimensions*4, cellDimensions*6,cellDimensions/13, paintBlack);
            canvas.drawCircle(cellDimensions*7, cellDimensions*6,cellDimensions/13, paintBlack);




        // draw fields for captured pieces
        // Player 2
        for (int i = 0; i < 7; i++){
            float x = (float) 0.5 * cellDimensions;
            float y = (float) 0.5 * cellDimensions + i * cellDimensions;
            canvas.drawCircle(x,y,capturedFieldRadius, paintCapturedField);
        }
        // Player 1
        for (int i = 2; i < 9; i++){
            float x = (float) 10.5 * cellDimensions;
            float y = (float) 0.5 * cellDimensions + i * cellDimensions;
            canvas.drawCircle(x,y,capturedFieldRadius, paintCapturedField);
        }


        // Scale bitmaps if necessary
        scaleBitmapsIfNeeded();

        /**
         * External Citation
         * Date: 16 September 2024
         * Problem: Tablet seemed to slow down after loading chess pieces
         * Resource: ChatGPT
         * Solution: I used their example code. Used synchronized() block in order to ensure the smoothness of drawing the 9 x 9 board
         * */

        // synchronized method draws all game pieces
        synchronized (shogiPieces) {
            for (int i = 0; i < shogiPieces.size(); i++) {
                ShogiPiece piece = shogiPieces.get(i);
                Bitmap scaledBitmap = scaledBitmaps.get(i);

                // Ensure the position is within bounds
                int row = Math.max(0, Math.min(piece.getRow(), 8));
                int col = Math.max(0, Math.min(piece.getCol(), 8));

                // Calculate the position to draw the Bitmap
                float left = col * cellDimensions;
                float top = row * cellDimensions;

                // Draw the Bitmap on the canvas
                canvas.drawBitmap(scaledBitmap, cellDimensions+left, top, null); // this has to be changed if captured and game Pieces are in on list
            }
        }

        // trying to have seperate GamePiece variable for capturePieces
        synchronized (capturedPieces) {
            for (int i = 0; i < capturedPieces.size(); i++) {
                ShogiPiece piece = capturedPieces.get(i);
                Bitmap scaledBitmap = scaledBitmaps.get(i);

                // Ensure the position is within bounds --- is this necessary

                // Calculate the position to draw the Bitmap
                float left;
                float top = piece.getRow() * cellDimensions;

                // check what section of captured player it is
                if(piece.getCol() == 1) left = (float) 10 * cellDimensions;
                else left = 0;

                // Draw the Bitmap on the canvas
                canvas.drawBitmap(scaledBitmap, left, top, null);
            }
        }
    }

    private void scaleBitmapsIfNeeded() {
        if (scaledBitmaps.isEmpty() || scaledBitmaps.get(0).getWidth() != (int) cellDimensions) {
            scaledBitmaps.clear();
            synchronized (shogiPieces) {
                for (ShogiPiece piece : shogiPieces) {
                   // Bitmap scaledBitmap = Bitmap.createScaledBitmap(piece.getBitmap(), (int) cellDimensions, (int) cellDimensions, true);
                  //  scaledBitmaps.add(scaledBitmap);
                }
            }

            synchronized (capturedPieces) {
                for (ShogiPiece piece : capturedPieces) {
                  //  Bitmap scaledBitmap = Bitmap.createScaledBitmap(piece.getBitmap(), (int) cellDimensions, (int) cellDimensions, true);
                  //  scaledBitmaps.add(scaledBitmap);
                }
            }
        }
    }
}
